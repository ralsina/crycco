<!DOCTYPE html>

<html lang="en" data-theme="dark">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>crycco.cr</title>
    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chivo+Mono:ital,wght@0,100..900;1,100..900&family=Chivo:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">    
    <!-- Pico CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.colors.min.css" />
    <!-- Highlight.js -->
    <link id="hljscss" rel="stylesheet"
        href="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/styles/night-owl.min.css" />
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/languages/crystal.min.js"></script>    <!-- Custom style-->
    
<style>
html * {
    font-family: Chivo, sans-serif;
    font-variant-ligatures: none;
    font-weight: 300;
    overflow: visible !important;
}

code,
code>* {
    font-family: 'Chivo Mono', monospace !important;
    padding-top: 0 !important;
}

div.doc>pre>code {
    background-color: var(--pico-color-slate-800);
    border: solid 1 var(--pico-color-slate-700)
}

.background {
    background: linear-gradient(to right, var(--pico-color-slate-900) 50%, #011627 50%);
    height: 100vh;
    width: 100vw;
    position: fixed;
    z-index: -1;
    margin: 0;
    top: 0px;
    left: 0px;
    display: block;
}
@media screen and (max-width: 768px) {
    div.background {
        display: none;
    }
}

span.anchor {
    position: relative;
}

a.anchor {
    position: absolute;
    text-decoration: none;
    left: -1.2em;
    opacity: 0;
    -webkit-transition: opacity 0.2s linear;
    
}

div.doc:hover .anchor {
    opacity: 1;
}

</style>

</head>

<body>
    <main class="container">
        
<div id="background" class="background">
</div>

<div id="section-1" class="grid">
    <div class="doc" id="section-1">
        <span class="anchor">
            <a href="#section-1" class="anchor">↦</a>
        </span>
        <h1>Crycco: A Crystal Remix of Docco.</h1>
<p>Crycco is a quick and dirty documentation generator in the mold
of and directly inspired by <a href="http://jashkenas.github.com/docco/">Docco</a>.</p>
<p>It creates HTML output that displays your comments alongside or
intermingled with your code. All comments are passed through Markdown
so they are nicely formatted and all code goes through a syntax
highlighter before being fed to <a href="templates.cr.html">templates</a>.</p>
<p>Crycco also supports the &quot;literate&quot; variant of languages, where
everything is a comment except things indented 4 spaces or more,
which are code. Those files should have a double <code>.ext.md</code> extension.</p>
<p>It's a very simple tool but it can be used to good effect in a number
of situations. Consider a tool that uses a YAML file as configuration.</p>
<p>Usually, one would have to write a README file to explain the format
of the config file, or worse, have the user read the YAML file itself
which will have a bunch of comments in there.</p>
<p>With crycco (or docco, or one of its many offshoots) you can generate
a nice HTML file that explains the config file in a much more readable
fashion, <a href="languages.yml.html"><strong>from the YAML itself</strong></a></p>
<p>Crycco also will let you do other manipulations on the code and docs,
like generating &quot;literate YAML&quot; out of YAML and viceversa. It says
&quot;it will&quot; because <a href="TODO.md.html">it doesn't yet</a></p>
<p>One of the best things about Docco in my opinion is that it takes the
tradition of literate programming and turns it into its minimal
expression, a tiny, simple tool that does one thing well.</p>
<p>This document is the output of running Crycco on
<a href="https://github.com/ralsina/crycco/blob/main/src/crycco.cr">its own source code</a>,
so if you keep reading we'll see how it works (it's short!).</p>
<p>If instead you are interested in the CLI tool, you can check out
<a href="main.cr.html">main.cr</a> which is the entry point for the
command line.</p>
<hr />

    </div>
    <div class="code">
        <pre class="code"><code class="crystal"></code></pre>
    </div>
</div>

<div id="section-2" class="grid">
    <div class="doc" id="section-2">
        <span class="anchor">
            <a href="#section-2" class="anchor">↦</a>
        </span>
        <h1>crycco.cr</h1>
<p>This is the main file of the project. It contains the main logic
for parsing the source files and generating the output.</p>
<hr />

    </div>
    <div class="code">
        <pre class="code"><code class="crystal"></code></pre>
    </div>
</div>

<div id="section-3" class="grid">
    <div class="doc" id="section-3">
        <span class="anchor">
            <a href="#section-3" class="anchor">↦</a>
        </span>
        <p>Import our dependencies</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">require &quot;./templates&quot;
require &quot;file_utils&quot;
require &quot;html&quot;
require &quot;markd&quot;
require &quot;yaml&quot;

</code></pre>
    </div>
</div>

<div id="section-4" class="grid">
    <div class="doc" id="section-4">
        <span class="anchor">
            <a href="#section-4" class="anchor">↦</a>
        </span>
        <p>In Crystal it's good to use modules to namespace the code. Specially since
Crycco also works as a library!</p>
<p>You can add it to a project and use it by adding it as a dependency in <code>shard.yml</code></p>
<pre><code class="language-yaml">dependencies:
  crycco:
    github: ralsina/crycco
</code></pre>
<p>And then in your code just <code>require &quot;crycco&quot;</code> and use it. I intend to do it in my
<a href="https://nicolino.ralsina.me">Nicolino</a> project.</p>
<p>For an example of how to use it, you can look at the <code>process</code> method at the end
of this file.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">module Crycco
  extend self
  VERSION = &quot;0.1.0&quot;

</code></pre>
    </div>
</div>

<div id="section-5" class="grid">
    <div class="doc" id="section-5">
        <span class="anchor">
            <a href="#section-5" class="anchor">↦</a>
        </span>
        <p>Languages are defined in a hash with the extension as the key</p>
<p>Each one contains the data required to parse a document in that
language, such as the comment symbol and a regex to match it.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  alias Language = Hash(String, String | Regex)
  LANGUAGES = Hash(String, Language).new

</code></pre>
    </div>
</div>

<div id="section-6" class="grid">
    <div class="doc" id="section-6">
        <span class="anchor">
            <a href="#section-6" class="anchor">↦</a>
        </span>
        <p>The <code>BakedLanguages</code> class embeds the languages definition file
in the actual binary so we don't have to carry it around.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  class BakedLanguages
    extend BakedFileSystem
    bake_file &quot;languages.yml&quot;, File.read(&quot;languages.yml&quot;)
  end

</code></pre>
    </div>
</div>

<div id="section-7" class="grid">
    <div class="doc" id="section-7">
        <span class="anchor">
            <a href="#section-7" class="anchor">↦</a>
        </span>
        <p>The description of how to parse a language is stored in a YAML file
which we read here in <code>Crycco.load_languages</code>. If no file is given
it defaults to the embedded one.</p>
<p>The <code>match</code> regex is used to detect if a line is a comment or code.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  def self.load_languages(file : String?)
    if file.nil?
      data = YAML.parse(BakedLanguages.get(&quot;/languages.yml&quot;))
    else
      data = YAML.parse(File.read(file))
    end
    data.as_h.each do |ext, lang|
      LANGUAGES[ext.to_s] = {
        &quot;name&quot;   =&gt; lang[&quot;name&quot;].to_s,
        &quot;symbol&quot; =&gt; lang[&quot;symbol&quot;].to_s,
        &quot;match&quot;  =&gt; /^\s*#{Regex.escape(lang[&quot;symbol&quot;].to_s)}\s?/,
      }
    end
  end

</code></pre>
    </div>
</div>

<div id="section-8" class="grid">
    <div class="doc" id="section-8">
        <span class="anchor">
            <a href="#section-8" class="anchor">↦</a>
        </span>
        <p>This matches shebangs and things that only LOOK like comments,
such as string interpolations.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  NOT_COMMENT = /(^#!|^\s*#\{)/

</code></pre>
    </div>
</div>

<div id="section-9" class="grid">
    <div class="doc" id="section-9">
        <span class="anchor">
            <a href="#section-9" class="anchor">↦</a>
        </span>
        <p>Document contents are organized in sections, which have docs and code.
The docs are markdown extracted from comments and the code is the actual code.</p>
<p>Sections can be converted to HTML using the <code>docs_html</code> and <code>code_html</code> methods.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  class Section
    property docs : String = &quot;&quot;
    property code : String = &quot;&quot;
    property language : Language

    def initialize(@language : Language)
    end

</code></pre>
    </div>
</div>

<div id="section-10" class="grid">
    <div class="doc" id="section-10">
        <span class="anchor">
            <a href="#section-10" class="anchor">↦</a>
        </span>
        <p><code>docs_html</code> converts the docs to HTML using the Markd library</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def docs_html
      Markd.to_html(docs)
    end

</code></pre>
    </div>
</div>

<div id="section-11" class="grid">
    <div class="doc" id="section-11">
        <span class="anchor">
            <a href="#section-11" class="anchor">↦</a>
        </span>
        <p>Since the generated HTML uses HighlightJS, we need to wrap the code in
a <code>&lt;pre&gt;&lt;code&gt;</code> block with the right class so it's properly highlighted.</p>
<p>It should also have the HTML escaped (or else this function would nest two pre tags
when passed through itself 😂). Finally, it has to be in a single line because
spaces are significant in code fragments.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def code_html
      %(&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;#{language[&quot;name&quot;]}&quot;&gt;) +
        %(#{HTML.escape(code.lstrip(&quot;\n&quot;))}) +
        &quot;&lt;/code&gt;&lt;/pre&gt;&quot;
    end

</code></pre>
    </div>
</div>

<div id="section-12" class="grid">
    <div class="doc" id="section-12">
        <span class="anchor">
            <a href="#section-12" class="anchor">↦</a>
        </span>
        <p><code>to_source</code> regenerates valid source code out of the section. This way if
the section was generated by a literate document, we can extract the code
and comments from it and save it to a file.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def to_source : String
      lines = [] of String
      docs.rstrip(&quot;\n&quot;).split(&quot;\n&quot;).each do |line|
        lines &lt;&lt; &quot;#{language[&quot;symbol&quot;]} #{line}&quot;
      end
      lines &lt;&lt; code.rstrip(&quot;\n&quot;)
      lines.join(&quot;\n&quot;)
    end

</code></pre>
    </div>
</div>

<div id="section-13" class="grid">
    <div class="doc" id="section-13">
        <span class="anchor">
            <a href="#section-13" class="anchor">↦</a>
        </span>
        <p>The <code>to_h</code> method is used to turn the section into something that can be
handled by the Crinja template engine. Just takes the data and put it in
a hash.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def to_h : Hash(String, String)
      {
        &quot;docs&quot;      =&gt; docs,
        &quot;code&quot;      =&gt; code,
        &quot;docs_html&quot; =&gt; docs_html,
        &quot;code_html&quot; =&gt; code_html,
        &quot;source&quot;    =&gt; to_source,
      }
    end
  end

</code></pre>
    </div>
</div>

<div id="section-14" class="grid">
    <div class="doc" id="section-14">
        <span class="anchor">
            <a href="#section-14" class="anchor">↦</a>
        </span>
        <p>A Document takes a path as input and reads the file,
parses its contents and is able to generate whatever
output is needed.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  class Document
    property path : String
    property sections = Array(Section).new
    property language : Language
    @literate : Bool = false

</code></pre>
    </div>
</div>

<div id="section-15" class="grid">
    <div class="doc" id="section-15">
        <span class="anchor">
            <a href="#section-15" class="anchor">↦</a>
        </span>
        <p>On initialization we read the file and parse it in the correct
language. Also, if rather than a <code>.yml</code> file we have a <code>.yml.md</code>
we consider that &quot;literate YAML&quot; and tweak the language
definition a bit.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def initialize(@path : String)
      key = File.extname(@path)
      if key == &quot;.md&quot; # It may be literate!
        lang_key = File.extname(File.basename(@path, &quot;.md&quot;))
        if LANGUAGES.has_key?(lang_key)
          key = lang_key
          @literate = true
        end
      end

      if LANGUAGES.has_key?(key)
        @language = LANGUAGES[key].clone
      else
        raise Exception.new &quot;Unknown language for file #{@path}&quot;
      end

</code></pre>
    </div>
</div>

<div id="section-16" class="grid">
    <div class="doc" id="section-16">
        <span class="anchor">
            <a href="#section-16" class="anchor">↦</a>
        </span>
        <p>In the literate versions, everything is doc except
indented things, which are code. So we change the
match regex to match everything except 4 spaces or a tab.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">      @language[&quot;match&quot;] = /^(?![ ]{4}|\t).*/ if @literate
      parse(File.read(@path))
    end

</code></pre>
    </div>
</div>

<div id="section-17" class="grid">
    <div class="doc" id="section-17">
        <span class="anchor">
            <a href="#section-17" class="anchor">↦</a>
        </span>
        <p>Given a string of source code, parse out each block of prose
and the code that follows it — by detecting which is which,
line by line — and then create an individual section for it.
Each section is an object with <code>docs</code> and <code>code</code> properties,
which can later be converted to HTML.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def parse(source : String)
      lines = source.split(&quot;\n&quot;)
      @sections = [Section.new language]

</code></pre>
    </div>
</div>

<div id="section-18" class="grid">
    <div class="doc" id="section-18">
        <span class="anchor">
            <a href="#section-18" class="anchor">↦</a>
        </span>
        <p>This loop is the core of the parser. It goes line by line
and decides if the line is a comment or code, and depending
on that either starts a new section, or adds to the current
one.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">      is_comment = language[&quot;match&quot;].as(Regex)
      lines.each do |line|
        if is_comment.match(line) &amp;&amp; !NOT_COMMENT.match(line)
</code></pre>
    </div>
</div>

<div id="section-19" class="grid">
    <div class="doc" id="section-19">
        <span class="anchor">
            <a href="#section-19" class="anchor">↦</a>
        </span>
        <p>Break section if we find docs after code</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">          @sections &lt;&lt; Section.new(language) unless sections[-1].code.empty?
</code></pre>
    </div>
</div>

<div id="section-20" class="grid">
    <div class="doc" id="section-20">
        <span class="anchor">
            <a href="#section-20" class="anchor">↦</a>
        </span>
        <p>Remove comment markers if it's not literate</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">          line = line.sub(language[&quot;match&quot;], &quot;&quot;) unless @literate
          @sections[-1].docs += line + &quot;\n&quot;
</code></pre>
    </div>
</div>

<div id="section-21" class="grid">
    <div class="doc" id="section-21">
        <span class="anchor">
            <a href="#section-21" class="anchor">↦</a>
        </span>
        <p>Also break section if we find a line of dashes (HR in markdown)</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">          @sections &lt;&lt; Section.new(language) if /^(---+|===+)$/.match line
        else
          @sections[-1].code += &quot;#{line}\n&quot;
        end
      end
</code></pre>
    </div>
</div>

<div id="section-22" class="grid">
    <div class="doc" id="section-22">
        <span class="anchor">
            <a href="#section-22" class="anchor">↦</a>
        </span>
        <p>Sections with no code or docs are pointless.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">      @sections.reject! { |section| section.code.strip.empty? &amp;&amp; section.docs.strip.empty? }
    end

</code></pre>
    </div>
</div>

<div id="section-23" class="grid">
    <div class="doc" id="section-23">
        <span class="anchor">
            <a href="#section-23" class="anchor">↦</a>
        </span>
        <p>Save the document to a file using the desired format
and template. If you want to learn more about the templates
you can check out <a href="templates.cr.html">templates.cr</a></p>
<p>If this is a literate document, remove any final .md
from the output file name because we are outputting
source code.</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">    def save(out_file, template = &quot;sidebyside&quot;)
      if @literate &amp;&amp; File.extname(out_file) == &quot;.md&quot;
        out_file = out_file[...-3]
      end

      FileUtils.mkdir_p(File.dirname(path))
      template = Templates.get(template)
      puts &quot;#{self.path} -&gt; #{out_file}&quot;
      FileUtils.mkdir_p(File.dirname(out_file))
      File.open(out_file, &quot;w&quot;) do |outf|
        outf &lt;&lt; template.render({
          &quot;title&quot;    =&gt; File.basename(path),
          &quot;sections&quot; =&gt; sections.map(&amp;.to_h),
          &quot;language&quot; =&gt; language[&quot;name&quot;],
        })
      end
    end
  end

</code></pre>
    </div>
</div>

<div id="section-24" class="grid">
    <div class="doc" id="section-24">
        <span class="anchor">
            <a href="#section-24" class="anchor">↦</a>
        </span>
        <p>The <code>process</code> function is the entry point to the whole thing.</p>
<p>Given a list of source files, create documents for each one
and save them to the output directory. You can see it being used
in <a href="main.cr.html">main.cr</a></p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal">  def process(sources : Array(String), out_dir : String, template : String, as_source = false)
    sources.each do |source|
      doc = Document.new(source)
      out_file = File.join(out_dir, File.basename(source) + &quot;.html&quot;)
      if as_source
        template = &quot;source&quot;
        out_file = out_file[...-5]
      end
      doc.save(out_file, template: template)
    end
  end
end

</code></pre>
    </div>
</div>

<div id="section-25" class="grid">
    <div class="doc" id="section-25">
        <span class="anchor">
            <a href="#section-25" class="anchor">↦</a>
        </span>
        <p>🏁 That's it!</p>

    </div>
    <div class="code">
        <pre class="code"><code class="crystal"></code></pre>
    </div>
</div>


    </main>
    <footer style="text-align: center;" class="pico-background-purple-800">
    » Generated by <a href="https://crycco.ralsina.me">Crycco</a> »	Layout 
sidebyside
 » Powered by <a href="https://picocss.com">PicoCSS</a> and <a href="https://www.omnibus-type.com/">Chivo Font Family</a> 
    </footer>
    <script>
        hljs.highlightAll();
    </script>
</body>

</html>